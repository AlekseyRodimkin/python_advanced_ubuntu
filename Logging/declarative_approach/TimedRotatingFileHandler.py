from logging.handlers import TimedRotatingFileHandler

TimedRotatingFileHandler(filename, when='h', interval=1,
                         backupCount=0, encoding=None,
                         delay=False, utc=False, atTime=None)
# Параметры:
# filename - имя файла лога,
# when='h' - тип интервала,
# interval=1 - интервал времени,
# backupCount=0 - количество хранимых логов,
# encoding=None - кодировка файла
# delay=False - задержка открытия файла,
# utc=False - использовать время UTC,
# atTime=None -
# Возвращаемое значение:
# объект TimedRotatingFileHandler.
# Описание:
# Класс logging.handlers.TimedRotatingFileHandler() возвращает новый экземпляр класса TimedRotatingFileHandler. Указанный файл открывается и используется в качестве потока для ведения журнала.
#
# При ротации TimedRotatingFileHandler() также устанавливает суффикс имени файла. Ротация происходит в зависимости от произведения аргументов, when и interval.
#
# Можно использовать аргумент when, что бы указать тип интервала. Список возможных значений приведен ниже. Обратите внимание, что они не чувствительны к регистру.
#
# Значение	Тип
# интервала	Kак используется atTime
# 'S'	Секунды	не использует
# 'M'	Минуты	не использует
# 'H'	Часы	не использует
# 'D'	Дни	не использует
# 'W0'-'W6'	Недели (0=Понедельник)	Используется для вычисления начального времени ротации
# 'midnight'	Если atTime не указано то ротация будет в полночь, если указано, то во время atTime.	Используется для вычисления начального времени ротации
# При использовании ротации на основе дня недели укажите W0 для понедельника, W1 для вторника и т. д. до W6 для воскресенья. В этом случае значение, переданное для интервала interval, не используется.
#
# Система сохранит старые файлы журнала, добавив расширения к имени файла. Расширения основаны на дате и времени, используя формат time.strftime() %Y-%m-%d_%H-%M-%S` или его начальную часть, в зависимости от интервала пролонгации.
#
# При вычислении следующего времени пролонгации в первый раз, когда создается обработчик, то для вычисления того, когда произойдет следующая ротация, используется время последней модификации существующего файла журнала или текущее время.
#
# Если аргумент utc=True, то будет использоваться время в формате UTC, в противном случае используется местное время.
#
# Если значение backupCount отлично от нуля, то будет сохранено не более файлов backupCount, а если при возникновении ротации будет создано больше файлов, то самый старый из них будет удален. Логика удаления использует интервал для определения удаляемого файла, поэтому изменение интервала может оставить старые файлы без изменений.
#
# Если задержка delay=True, то открытие файла откладывается до первого вызова метода emit().
#
# Если аргумент atTime не равен None, то это должен быть экземпляр datetime.time(), который указывает время суток для случаев, когда ротация происходит в полночь или в определенный день недели. Обратите внимание, что в этих случаях значение atTime эффективно используется для вычисления начальной ротации, а последующие ротации будут рассчитываться с помощью вычисления нормального интервала.
#
# Примечание. Расчет начального времени ротации выполняется при инициализации обработчика. Расчет последующих времен ротации выполняется только при ротации, а ротации происходит только при выдаче выходных данных. Если это не учитывать, это может привести к некоторой путанице.
#
# Например, если установлен интервал каждую минуту, это не значит, что вы всегда будете видеть файлы журнала с временами в имени файла, разделенными минутой. Если во время выполнения приложения выходные данные журнала генерируются чаще, чем раз в минуту, то можно ожидать, что файлы журнала будут отображаться с разделением времени на минуту. С другой стороны, допустим, что сообщения регистрируются только один раз каждые пять минут, то в файлах будут временные интервалы, соответствующие минутам, в которых не было никакого вывода.
#
# Методы объекта TimedRotatingFileHandler.
# doRollover():
# Производит ротацию, как описано выше.
#
# emit(record):
# Выводит запись record в файл, обеспечивая ротацию, как описано выше.