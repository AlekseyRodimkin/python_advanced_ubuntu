
class TreeNode:
    def __init__(self, val):
        self.val = val  # переданное значение, будет храниться в узле
        self.left = None  # значение узла
        self.right = None  # значение узла

# Если речь идет о двоичном дереве, единственное,
# что его отличает от связного списка, это то,
# что вместо next у нас тут есть left и right.

# Верхний узел имеет значение 1.
# Далее мы устанавливаем левые и правые узлы,
# пока не получим желаемое дерево.
# 1[2[4, 5], 3[]]


tree = TreeNode(1)
tree.left = TreeNode(2)
tree.right = TreeNode(3)
tree.left.left = TreeNode(4)
tree.left.right = TreeNode(5)

# Нет никакой команды, которая позволила бы вывести на экран
# дерево целиком, тем не менее мы можем обойти его, посетив каждый
# узел. Но в каком порядке выводить узлы?

# Самые простые в реализации обходы дерева — прямой (Pre-Order),
# обратный (Post-Order) и центрированный (In-Order).
# Вы также можете услышать такие термины, как поиск в ширину и
# поиск в глубину, но их реализация сложнее.

# При прямом обходе мы посещаем родительские узлы до
# посещения узлов-потомков. В случае с нашим деревом мы будем
# обходить узлы в таком порядке: 1, 2, 4, 5, 3.
#
# Обратный обход двоичного дерева — это когда вы сначала
# посещаете узлы-потомки, а затем — их родительские узлы.
# В нашем случае порядок посещения узлов при обратном обходе
# будет таким: 4, 5, 2, 3, 1.
#
# При центрированном обходе мы посещаем все узлы слева направо.
# Центрированный обход нашего дерева —
# это посещение узлов 4, 2, 5, 1, 3.

# Pre-Order
# Начнем с определения метода pre_order().
# Наш метод принимает один аргумент — корневой узел (расположенный выше всех).

# def pre_order(node):
#     pass

# Дальше нам нужно проверить, существует ли этот узел.
# Вы можете возразить, что лучше бы проверить существование потомков этого узла перед их посещением.
# Но для этого нам пришлось бы написать два if-предложения, а так мы обойдемся одним.

# def pre_order(node):
#     if node:
#         pass

# Написать обход просто. Прямой обход — это посещение родительского узла,
# а затем каждого из его потомков. Мы «посетим» родительский узел,
# выведя его на экран, а затем «обойдем» детей,
# вызывая этот метод рекурсивно для каждого узла-потомка.

# Выводит родителя до всех его потомков
def pre_order(node):
    if node:
        print(node.value)s
        pre_order(node.left)
        pre_order(node.right)

# Просто, правда? Можем протестировать этот код, совершив обход построенного ранее дерева.

 pre_order(tree)
# Результат:
#
#  1
#  2
#  4
#  5
#  3


# Post-Order
# Переходим к обратному обходу. Возможно, вы думаете,
# что для этого нужно написать еще один метод, но на самом деле нам нужно изменить всего одну строчку в предыдущем.
#
# Вместо «посещения» родительского узла и последующего «обхода» детей,
# мы сначала «обойдем» детей, а затем «посетим» родительский узел.
# То есть, мы просто передвинем print на последнюю строку!
# Не забудьте поменять имя метода на post_order() во всех вызовах.

# Выводит потомков, а затем родителя
def post_order(node):
    if node:
        post_order(node.left)
        post_order(node.right)
        print(node.value)

# В выводе мы получим:
#
#  4
#  5
#  2
#  3
#  1

# Каждый узел-потомок посещен до посещения его родителя.


# In-Order
# Наконец, напишем метод центрированного обхода.
# Как нам обойти левый узел, затем родительский, а затем правый?
# Опять же, нужно переместить предложение print!

# выводит левого потомка, затем родителя, затем правого потомка
def in_order(node):
    if node:
        in_order(node.left)
        print(node.value)
        in_order(node.right)
# Результат:
#
#  4
#  2
#  5
#  1
#  3
# Вот и все, мы рассмотрели три простейших способа совершить обход двоичного дерева.